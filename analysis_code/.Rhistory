cluster_i
Ri
Yi
pars$phi
Xi
for(i in 1:num_kids){
cluster_i = which(Orthodont$id == i)
ni = length(cluster_i)
Ri = get_Ri(pars, ni)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[cluster_i,])
Yi = Orthodont$distance[cluster_i]
resids_i = Yi - Xi %*% pars$beta
ef = ef + Xi %*% solve(Ri * pars$phi) %*% resids_i
breadinv = breadinv + Xi %*% solve(Ri * pars$phi) %*% Xi
print(Xi)
}
Xi
Xi
rm(list = ls())
data(Orthodont, package="nlme")
Orthodont$age = Orthodont$age - 8
Orthodont$Sex = factor(Orthodont$Sex, levels = c("Female", "Male"))
num_kids = 27
Orthodont$id = rep(1:num_kids, each = 4)
COR_OPTS = c("independent", "exchangeable", "autoregressive")
names(COR_OPTS) = COR_OPTS
MAX_ITER = 2000
# This function does fisher scoring for gees with any working correlation assumption.
# Data and formula are hardcoded for simplicity.
# For reference: under the current model,
#     t(Di) == (Xi) (canonical link)
#     mui = Xi beta (linear)
#     V == phi Ri (homoskedastic)
gee_eric = function(corstr){
assertthat::assert_that(corstr %in% COR_OPTS)
#This closure forms a cluster working correlation matrix
#given estimated parameters and cluster size.
get_Ri = function(pars, ni){
assertthat::assert_that(corstr %in% COR_OPTS)
if(corstr == COR_OPTS["independent"]){
Ri = diag(ni)
} else if(corstr == COR_OPTS["exchangeable"] ){
Ri = matrix(rep(pars$alpha, ni^2), nrow = ni)
diag(Ri) = 1
} else if(corstr == COR_OPTS["autoregressive"] ){
Ri = toeplitz(cumprod(rep(pars$alpha, ni))/pars$alpha)
}
return(Ri)
}
#This closure estimates working correlation matrix parameters.
update_alpha = function(pars){
assertthat::assert_that(corstr %in% COR_OPTS)
for(i in 1:num_kids){
ni = sum(Orthodont$id == i)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[Orthodont$id==i,])
Yi = Orthodont$distance[Orthodont$id==i]
resids_i = (Yi - Xi %*% pars$beta) / pars$phi
num_terms = 0
if( corstr == COR_OPTS["independent"] ){
assertthat::assert_that(is.null(pars$alpha))
} else if( corstr == COR_OPTS["exchangeable"] ){
pars$alpha = pars$alpha + ( sum(resids_i)^2 - sum(resids_i^2) )
num_terms = num_terms + (ni^2 - ni)
} else if( corstr == COR_OPTS["autoregressive"] ){
pars$alpha = pars$alpha + sum(resids_i[1:(ni - 1)]*resids_i[2:ni])
num_terms = num_terms + (ni - 1)
}
if(!is.null(!pars$alpha)){
pars$alpha = pars$alpha / num_terms
}
}
return(pars)
}
#This closure updates estimates for regression coeffs.
update_beta = function(pars){
ef = c(0, 0, 0, 0)
breadinv = matrix(rep(0, 16), nrow = 4)
meat = matrix(rep(0, 16), nrow = 4)
for(i in 1:num_kids){
cluster_i = which(Orthodont$id == i)
ni = length(cluster_i)
Ri = get_Ri(pars, ni)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[cluster_i,])
Yi = Orthodont$distance[cluster_i]
resids_i = Yi - Xi %*% pars$beta
ef = ef + t(Xi) %*% solve(Ri * pars$phi) %*% resids_i
breadinv = breadinv + t(Xi) %*% solve(Ri * pars$phi) %*% Xi
}
pars$beta = solve(breadinv, ef)
return(pars)
}
#This closure updates the estimated scale parameter.
update_phi = function(pars){
X = model.matrix(distance ~ Sex * age, data = Orthodont)
pars$phi = sum( (Orthodont$distance - X %*% pars$beta)^2 ) /
( length(Orthodont$distance) - length(pars$beta) )
return(pars)
}
#This closure creates sandwich estimates
get_sandwich = function(pars){
breadinv = matrix(rep(0, 16), nrow = 4)
meat = matrix(rep(0, 16), nrow = 4)
for(i in 1:num_kids){
ni = sum(Orthodont$id == i)
Ri = get_R(pars$alpha, ni)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[Orthodont$id==i,])
Yi = Orthodont$distance[Orthodont$id==i]
resids_i = Yi - Xi %*% pars$beta
breadinv = breadinv + t(Xi) %*% solve(Ri * pars$phi) %*% Xi
root_vegetables = t(Xi) %*% solve(Ri * pars$phi) %*% resids_i
meat = meat + root_vegetables %*% t(root_vegetables)
}
sandwich = solve(breadinv) %*% meat %*% solve(breadinv)
return(sandwich)
}
distance_Linf = function(old_pars, pars){
return(max(abs(c(old_pars$beta,
old_pars$phi,
old_pars$alpha) -
c(pars$beta,
pars$phi,
pars$alpha))))
}
#This loop puts it all together to run fisher scoring for GEE's.
pars = list(beta = rep(0.5, 4), phi = 1)
if(corstr != "independent"){ pars$alpha = 0.2 }
for(i in 1:MAX_ITER){
old_pars = pars
pars = update_beta(pars)
pars = update_phi(pars)
pars = update_alpha(pars)
if(distance_Linf(old_pars, pars) < 1e-8){
return(list(argmins = pars, num_iters = i, sandwich = get_sandwich(pars)))
}
}
warning("No convergence: quitting early in gee_eric.")
return(list(argmins = pars, num_iters = -1, sandwich = get_sandwich(pars)))
}
gee_eric(corstr = "independent")
rm(list = ls())
data(Orthodont, package="nlme")
Orthodont$age = Orthodont$age - 8
Orthodont$Sex = factor(Orthodont$Sex, levels = c("Female", "Male"))
num_kids = 27
Orthodont$id = rep(1:num_kids, each = 4)
COR_OPTS = c("independent", "exchangeable", "autoregressive")
names(COR_OPTS) = COR_OPTS
MAX_ITER = 2000
# This function does fisher scoring for gees with any working correlation assumption.
# Data and formula are hardcoded for simplicity.
# For reference: under the current model,
#     t(Di) == (Xi) (canonical link)
#     mui = Xi beta (linear)
#     V == phi Ri (homoskedastic)
gee_eric = function(corstr){
assertthat::assert_that(corstr %in% COR_OPTS)
#This closure forms a cluster working correlation matrix
#given estimated parameters and cluster size.
get_Ri = function(pars, ni){
assertthat::assert_that(corstr %in% COR_OPTS)
if(corstr == COR_OPTS["independent"]){
Ri = diag(ni)
} else if(corstr == COR_OPTS["exchangeable"] ){
Ri = matrix(rep(pars$alpha, ni^2), nrow = ni)
diag(Ri) = 1
} else if(corstr == COR_OPTS["autoregressive"] ){
Ri = toeplitz(cumprod(rep(pars$alpha, ni))/pars$alpha)
}
return(Ri)
}
#This closure estimates working correlation matrix parameters.
update_alpha = function(pars){
for(i in 1:num_kids){
ni = sum(Orthodont$id == i)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[Orthodont$id==i,])
Yi = Orthodont$distance[Orthodont$id==i]
resids_i = (Yi - Xi %*% pars$beta) / pars$phi
num_terms = 0
if( corstr == COR_OPTS["independent"] ){
assertthat::assert_that(is.null(pars$alpha))
} else if( corstr == COR_OPTS["exchangeable"] ){
pars$alpha = pars$alpha + ( sum(resids_i)^2 - sum(resids_i^2) )
num_terms = num_terms + (ni^2 - ni)
} else if( corstr == COR_OPTS["autoregressive"] ){
pars$alpha = pars$alpha + sum(resids_i[1:(ni - 1)]*resids_i[2:ni])
num_terms = num_terms + (ni - 1)
}
if(!is.null(pars$alpha)){
pars$alpha = pars$alpha / num_terms
}
}
return(pars)
}
#This closure updates estimates for regression coeffs.
update_beta = function(pars){
ef = c(0, 0, 0, 0)
breadinv = matrix(rep(0, 16), nrow = 4)
meat = matrix(rep(0, 16), nrow = 4)
for(i in 1:num_kids){
cluster_i = which(Orthodont$id == i)
ni = length(cluster_i)
Ri = get_Ri(pars, ni)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[cluster_i,])
Yi = Orthodont$distance[cluster_i]
resids_i = Yi - Xi %*% pars$beta
ef = ef + t(Xi) %*% solve(Ri * pars$phi) %*% resids_i
breadinv = breadinv + t(Xi) %*% solve(Ri * pars$phi) %*% Xi
}
pars$beta = solve(breadinv, ef)
return(pars)
}
#This closure updates the estimated scale parameter.
update_phi = function(pars){
X = model.matrix(distance ~ Sex * age, data = Orthodont)
pars$phi = sum( (Orthodont$distance - X %*% pars$beta)^2 ) /
( length(Orthodont$distance) - length(pars$beta) )
return(pars)
}
#This closure creates sandwich estimates
get_sandwich = function(pars){
breadinv = matrix(rep(0, 16), nrow = 4)
meat = matrix(rep(0, 16), nrow = 4)
for(i in 1:num_kids){
ni = sum(Orthodont$id == i)
Ri = get_R(pars$alpha, ni)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[Orthodont$id==i,])
Yi = Orthodont$distance[Orthodont$id==i]
resids_i = Yi - Xi %*% pars$beta
breadinv = breadinv + t(Xi) %*% solve(Ri * pars$phi) %*% Xi
root_vegetables = t(Xi) %*% solve(Ri * pars$phi) %*% resids_i
meat = meat + root_vegetables %*% t(root_vegetables)
}
sandwich = solve(breadinv) %*% meat %*% solve(breadinv)
return(sandwich)
}
distance_Linf = function(old_pars, pars){
return(max(abs(c(old_pars$beta,
old_pars$phi,
old_pars$alpha) -
c(pars$beta,
pars$phi,
pars$alpha))))
}
#This loop puts it all together to run fisher scoring for GEE's.
pars = list(beta = rep(0.5, 4), phi = 1)
if(corstr != "independent"){ pars$alpha = 0.2 }
for(i in 1:MAX_ITER){
old_pars = pars
pars = update_beta(pars)
pars = update_phi(pars)
pars = update_alpha(pars)
if(distance_Linf(old_pars, pars) < 1e-8){
return(list(argmins = pars, num_iters = i, sandwich = get_sandwich(pars)))
}
}
warning("No convergence: quitting early in gee_eric.")
return(list(argmins = pars, num_iters = -1, sandwich = get_sandwich(pars)))
}
gee_eric(corstr = "independent")
rm(list = ls())
data(Orthodont, package="nlme")
Orthodont$age = Orthodont$age - 8
Orthodont$Sex = factor(Orthodont$Sex, levels = c("Female", "Male"))
num_kids = 27
Orthodont$id = rep(1:num_kids, each = 4)
COR_OPTS = c("independent", "exchangeable", "autoregressive")
names(COR_OPTS) = COR_OPTS
MAX_ITER = 200
# This function does fisher scoring for gees with any working correlation assumption.
# Data and formula are hardcoded for simplicity.
# For reference: under the current model,
#     t(Di) == (Xi) (canonical link)
#     mui = Xi beta (linear)
#     V == phi Ri (homoskedastic)
gee_eric = function(corstr){
assertthat::assert_that(corstr %in% COR_OPTS)
#This closure forms a cluster working correlation matrix
#given estimated parameters and cluster size.
get_Ri = function(pars, ni){
assertthat::assert_that(corstr %in% COR_OPTS)
if(corstr == COR_OPTS["independent"]){
Ri = diag(ni)
} else if(corstr == COR_OPTS["exchangeable"] ){
Ri = matrix(rep(pars$alpha, ni^2), nrow = ni)
diag(Ri) = 1
} else if(corstr == COR_OPTS["autoregressive"] ){
Ri = toeplitz(cumprod(rep(pars$alpha, ni))/pars$alpha)
}
return(Ri)
}
#This closure estimates working correlation matrix parameters.
update_alpha = function(pars){
for(i in 1:num_kids){
ni = sum(Orthodont$id == i)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[Orthodont$id==i,])
Yi = Orthodont$distance[Orthodont$id==i]
resids_i = (Yi - Xi %*% pars$beta) / pars$phi
num_terms = 0
if( corstr == COR_OPTS["independent"] ){
assertthat::assert_that(is.null(pars$alpha))
} else if( corstr == COR_OPTS["exchangeable"] ){
pars$alpha = pars$alpha + ( sum(resids_i)^2 - sum(resids_i^2) )
num_terms = num_terms + (ni^2 - ni)
} else if( corstr == COR_OPTS["autoregressive"] ){
pars$alpha = pars$alpha + sum(resids_i[1:(ni - 1)]*resids_i[2:ni])
num_terms = num_terms + (ni - 1)
}
if(!is.null(pars$alpha)){
pars$alpha = pars$alpha / num_terms
}
}
return(pars)
}
#This closure updates estimates for regression coeffs.
update_beta = function(pars){
ef = c(0, 0, 0, 0)
breadinv = matrix(rep(0, 16), nrow = 4)
meat = matrix(rep(0, 16), nrow = 4)
for(i in 1:num_kids){
cluster_i = which(Orthodont$id == i)
ni = length(cluster_i)
Ri = get_Ri(pars, ni)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[cluster_i,])
Yi = Orthodont$distance[cluster_i]
resids_i = Yi - Xi %*% pars$beta
ef = ef + t(Xi) %*% solve(Ri * pars$phi) %*% resids_i
breadinv = breadinv + t(Xi) %*% solve(Ri * pars$phi) %*% Xi
}
pars$beta = solve(breadinv, ef)
return(pars)
}
#This closure updates the estimated scale parameter.
update_phi = function(pars){
X = model.matrix(distance ~ Sex * age, data = Orthodont)
pars$phi = sum( (Orthodont$distance - X %*% pars$beta)^2 ) /
( length(Orthodont$distance) - length(pars$beta) )
return(pars)
}
#This closure creates sandwich estimates
get_sandwich = function(pars){
breadinv = matrix(rep(0, 16), nrow = 4)
meat = matrix(rep(0, 16), nrow = 4)
for(i in 1:num_kids){
ni = sum(Orthodont$id == i)
Ri = get_R(pars$alpha, ni)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[Orthodont$id==i,])
Yi = Orthodont$distance[Orthodont$id==i]
resids_i = Yi - Xi %*% pars$beta
breadinv = breadinv + t(Xi) %*% solve(Ri * pars$phi) %*% Xi
root_vegetables = t(Xi) %*% solve(Ri * pars$phi) %*% resids_i
meat = meat + root_vegetables %*% t(root_vegetables)
}
sandwich = solve(breadinv) %*% meat %*% solve(breadinv)
return(sandwich)
}
distance_Linf = function(old_pars, pars){
return(max(abs(c(old_pars$beta,
old_pars$phi,
old_pars$alpha) -
c(pars$beta,
pars$phi,
pars$alpha))))
}
#This loop puts it all together to run fisher scoring for GEE's.
pars = list(beta = rep(0.5, 4), phi = 1)
if(corstr != "independent"){ pars$alpha = 0.2 }
for(i in 1:MAX_ITER){
print(i)
old_pars = pars
pars = update_beta(pars)
pars = update_phi(pars)
pars = update_alpha(pars)
if(distance_Linf(old_pars, pars) < 1e-8){
return(list(argmins = pars, num_iters = i, sandwich = get_sandwich(pars)))
}
}
warning("No convergence: quitting early in gee_eric.")
return(list(argmins = pars, num_iters = -1, sandwich = get_sandwich(pars)))
}
gee_eric(corstr = "independent")
rm(list = ls())
data(Orthodont, package="nlme")
Orthodont$age = Orthodont$age - 8
Orthodont$Sex = factor(Orthodont$Sex, levels = c("Female", "Male"))
num_kids = 27
Orthodont$id = rep(1:num_kids, each = 4)
COR_OPTS = c("independent", "exchangeable", "autoregressive")
names(COR_OPTS) = COR_OPTS
MAX_ITER = 200
# This function does fisher scoring for gees with any working correlation assumption.
# Data and formula are hardcoded for simplicity.
# For reference: under the current model,
#     t(Di) == (Xi) (canonical link)
#     mui = Xi beta (linear)
#     V == phi Ri (homoskedastic)
gee_eric = function(corstr){
assertthat::assert_that(corstr %in% COR_OPTS)
#This closure forms a cluster working correlation matrix
#given estimated parameters and cluster size.
get_Ri = function(pars, ni){
assertthat::assert_that(corstr %in% COR_OPTS)
if(corstr == COR_OPTS["independent"]){
Ri = diag(ni)
} else if(corstr == COR_OPTS["exchangeable"] ){
Ri = matrix(rep(pars$alpha, ni^2), nrow = ni)
diag(Ri) = 1
} else if(corstr == COR_OPTS["autoregressive"] ){
Ri = toeplitz(cumprod(rep(pars$alpha, ni))/pars$alpha)
}
return(Ri)
}
#This closure estimates working correlation matrix parameters.
update_alpha = function(pars){
for(i in 1:num_kids){
ni = sum(Orthodont$id == i)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[Orthodont$id==i,])
Yi = Orthodont$distance[Orthodont$id==i]
resids_i = (Yi - Xi %*% pars$beta) / pars$phi
num_terms = 0
if( corstr == COR_OPTS["independent"] ){
assertthat::assert_that(is.null(pars$alpha))
} else if( corstr == COR_OPTS["exchangeable"] ){
pars$alpha = pars$alpha + ( sum(resids_i)^2 - sum(resids_i^2) )
num_terms = num_terms + (ni^2 - ni)
} else if( corstr == COR_OPTS["autoregressive"] ){
pars$alpha = pars$alpha + sum(resids_i[1:(ni - 1)]*resids_i[2:ni])
num_terms = num_terms + (ni - 1)
}
if(!is.null(pars$alpha)){
pars$alpha = pars$alpha / num_terms
}
}
return(pars)
}
#This closure updates estimates for regression coeffs.
update_beta = function(pars){
ef = c(0, 0, 0, 0)
breadinv = matrix(rep(0, 16), nrow = 4)
meat = matrix(rep(0, 16), nrow = 4)
for(i in 1:num_kids){
cluster_i = which(Orthodont$id == i)
ni = length(cluster_i)
Ri = get_Ri(pars, ni)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[cluster_i,])
Yi = Orthodont$distance[cluster_i]
resids_i = Yi - Xi %*% pars$beta
ef = ef + t(Xi) %*% solve(Ri * pars$phi) %*% resids_i
breadinv = breadinv + t(Xi) %*% solve(Ri * pars$phi) %*% Xi
}
pars$beta = solve(breadinv, ef)
return(pars)
}
#This closure updates the estimated scale parameter.
update_phi = function(pars){
X = model.matrix(distance ~ Sex * age, data = Orthodont)
pars$phi = sum( (Orthodont$distance - X %*% pars$beta)^2 ) /
( length(Orthodont$distance) - length(pars$beta) )
return(pars)
}
#This closure creates sandwich estimates
get_sandwich = function(pars){
breadinv = matrix(rep(0, 16), nrow = 4)
meat = matrix(rep(0, 16), nrow = 4)
for(i in 1:num_kids){
ni = sum(Orthodont$id == i)
Ri = get_R(pars$alpha, ni)
Xi = model.matrix(distance ~ Sex * age, data = Orthodont[Orthodont$id==i,])
Yi = Orthodont$distance[Orthodont$id==i]
resids_i = Yi - Xi %*% pars$beta
breadinv = breadinv + t(Xi) %*% solve(Ri * pars$phi) %*% Xi
root_vegetables = t(Xi) %*% solve(Ri * pars$phi) %*% resids_i
meat = meat + root_vegetables %*% t(root_vegetables)
}
sandwich = solve(breadinv) %*% meat %*% solve(breadinv)
return(sandwich)
}
distance_Linf = function(old_pars, pars){
return(max(abs(c(old_pars$beta,
old_pars$phi,
old_pars$alpha) -
c(pars$beta,
pars$phi,
pars$alpha))))
}
#This loop puts it all together to run fisher scoring for GEE's.
pars = list(beta = rep(0.5, 4), phi = 1)
if(corstr != "independent"){ pars$alpha = 0.2 }
for(i in 1:MAX_ITER){
print(i)
print(pars$beta)
old_pars = pars
pars = update_beta(pars)
pars = update_phi(pars)
pars = update_alpha(pars)
if(distance_Linf(old_pars, pars) < 1e-8){
return(list(argmins = pars, num_iters = i, sandwich = get_sandwich(pars)))
}
}
warning("No convergence: quitting early in gee_eric.")
return(list(argmins = pars, num_iters = -1, sandwich = get_sandwich(pars)))
}
gee_eric(corstr = "independent")
X = model.matrix(distance ~ Sex * age, data = Orthodont)
X
View(X)
rm(list = ls())
PATH_TO_THIS_FILE = "~/Desktop/winter_2016/consulting/Leah Perlmutter (cs)/transparency_analysis/analysis_code/"
warning(paste("The path", PATH_TO_THIS_FILE, "should point to transparency_analysis_functions.Rmd and transparency_analysis_script.Rmd."))
setwd(PATH_TO_THIS_FILE)
require(knitr)
knitr::purl("transparency_analysis_functions.Rmd")
source("transparency_analysis_functions.R")
